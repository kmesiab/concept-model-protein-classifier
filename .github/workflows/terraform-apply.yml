name: Terraform Apply

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "apply" to confirm infrastructure changes'
        required: true
        type: string
      plan_run_id:
        description: 'Optional: Workflow run ID containing cached Terraform plan'
        required: false
        type: string
        default: ''

# Prevent concurrent Terraform runs to avoid state lock conflicts
concurrency:
  group: terraform-apply
  cancel-in-progress: false

permissions:
  contents: read
  id-token: write
  pull-requests: write

env:
  COST_THRESHOLD: 125  # Monthly cost threshold in USD

jobs:
  validate:
    name: Pre-Apply Validation (Triple-Gated)
    runs-on: ubuntu-latest

    steps:
      - name: Verify Confirmation
        run: |
          if [ "${{ inputs.confirm }}" != "apply" ]; then
            echo "‚ùå Confirmation failed. You must type 'apply' to proceed."
            exit 1
          fi
          echo "‚úÖ Confirmation received. Proceeding with validation..."

      - name: Checkout code
        uses: actions/checkout@v6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/github-actions-terraform
          aws-region: ${{ vars.TF_STATE_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: latest

      - name: Terraform Init
        env:
          TF_STATE_BUCKET: ${{ vars.TF_STATE_BUCKET }}
          TF_STATE_KEY: ${{ vars.TF_STATE_KEY }}
          TF_STATE_REGION: ${{ vars.TF_STATE_REGION }}
          TF_STATE_DYNAMODB_TABLE: ${{ vars.TF_STATE_DYNAMODB_TABLE }}
        run: |
          terraform -chdir=terraform init \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="region=${TF_STATE_REGION}" \
            -backend-config="dynamodb_table=${TF_STATE_DYNAMODB_TABLE}"

      # Gate 1: TFLint
      - name: Gate 1 - TFLint Validation
        run: |
          cd terraform
          tflint --init
          echo "üîç Running TFLint validation..."
          tflint --format compact --minimum-failure-severity=error
          echo "‚úÖ Gate 1 (TFLint) PASSED"

      # Gate 2: Trivy Terraform Security Scan
      - name: Gate 2 - Trivy Terraform Scan
        id: trivy
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'config'
          scan-ref: 'terraform'
          format: 'json'
          output: 'trivy-terraform.json'
          exit-code: '0'  # Don't fail the action itself, we'll parse results

      - name: Gate 2 Status
        if: always()
        run: |
          echo "### üîí Gate 2: Trivy Terraform Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          REPORT=trivy-terraform.json
          if [ -f "$REPORT" ]; then
            TOTAL=$(jq -r '(.Results // []) | map(.Misconfigurations // []) | flatten | length' "$REPORT")
            # Count findings by severity level
            CRITICAL=$(jq -r '(.Results // []) | map(.Misconfigurations // []) | flatten | map(select(.Severity=="CRITICAL")) | length' "$REPORT")
            HIGH=$(jq -r '(.Results // []) | map(.Misconfigurations // []) | flatten | map(select(.Severity=="HIGH")) | length' "$REPORT")
            MEDIUM=$(jq -r '(.Results // []) | map(.Misconfigurations // []) | flatten | map(select(.Severity=="MEDIUM")) | length' "$REPORT")
            LOW=$(jq -r '(.Results // []) | map(.Misconfigurations // []) | flatten | map(select(.Severity=="LOW")) | length' "$REPORT")

            echo "- Findings: $TOTAL" >> $GITHUB_STEP_SUMMARY
            echo "  - CRITICAL: $CRITICAL" >> $GITHUB_STEP_SUMMARY
            echo "  - HIGH:     $HIGH" >> $GITHUB_STEP_SUMMARY
            echo "  - MEDIUM:   $MEDIUM" >> $GITHUB_STEP_SUMMARY
            echo "  - LOW:      $LOW" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Validate TOTAL is a number before comparison
            if [[ "$TOTAL" =~ ^[0-9]+$ ]]; then
              if [ "$TOTAL" -gt 0 ]; then
                echo "‚ùå Security issues detected"
                echo "**Security findings must be addressed before applying infrastructure changes.**"
                echo ""
                echo "Security findings breakdown:"
                echo "  - CRITICAL: $CRITICAL"
                echo "  - HIGH: $HIGH"
                echo "  - MEDIUM: $MEDIUM"
                echo "  - LOW: $LOW"
                echo ""
                echo "Running Trivy with detailed output:"
                echo ""
                docker run --rm -v "${GITHUB_WORKSPACE:-$PWD}:/src" aquasec/trivy:latest config /src/terraform
                echo ""
                echo "‚ùå Gate 2 (Trivy) FAILED"
                echo "‚ùå Security issues detected" >> $GITHUB_STEP_SUMMARY
                echo "**Security findings must be addressed before applying infrastructure changes.**" >> $GITHUB_STEP_SUMMARY
                echo "‚ùå Gate 2 (Trivy) FAILED" >> $GITHUB_STEP_SUMMARY
                exit 1
              else
                echo "‚úÖ No security issues found"
                echo "‚úÖ Gate 2 (Trivy) PASSED"
                echo "‚úÖ No security issues found" >> $GITHUB_STEP_SUMMARY
                echo "‚úÖ Gate 2 (Trivy) PASSED" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "‚ö†Ô∏è Unable to parse Trivy findings count from report (TOTAL=\"$TOTAL\")."
              echo "‚ùå Gate 2 (Trivy) FAILED"
              echo "‚ö†Ô∏è Unable to parse Trivy findings count from report (TOTAL=\"$TOTAL\")." >> $GITHUB_STEP_SUMMARY
              echo "‚ùå Gate 2 (Trivy) FAILED" >> $GITHUB_STEP_SUMMARY
              exit 1
            fi
          else
            # Report file is missing - this is an error condition
            echo "‚ùå Trivy report file not found"
            echo "‚ùå Gate 2 (Trivy) FAILED"
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ùå Trivy report file not found - cannot verify security posture" >> $GITHUB_STEP_SUMMARY
            echo "‚ùå Gate 2 (Trivy) FAILED" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      # Gate 3: Cost Estimation
      - name: Setup Infracost
        uses: infracost/actions/setup@v3
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY }}

      - name: Gate 3 - Cost Estimation
        continue-on-error: true # Skip cost estimation gate for now
        run: |
          cd terraform
          echo "üí∞ Generating cost estimate..."
          infracost breakdown --path . \
            --terraform-var="aws_account_id=${{ vars.AWS_ACCOUNT_ID || '000000000000' }}" \
            --format json \
            --out-file /tmp/infracost.json
          
          # Extract total monthly cost
          TOTAL_COST=$(jq -r '.totalMonthlyCost' /tmp/infracost.json)
          THRESHOLD=${{ env.COST_THRESHOLD }}
          
          echo "üìä Total Monthly Cost: \$$TOTAL_COST"
          echo "üéØ Cost Threshold: \$$THRESHOLD"
          
          # Compare costs (using bc for decimal comparison)
          if [ $(echo "$TOTAL_COST > $THRESHOLD" | bc -l) -eq 1 ]; then
            echo "‚ùå COST THRESHOLD EXCEEDED!"
            echo "   Estimated: \$$TOTAL_COST/month"
            echo "   Threshold: \$$THRESHOLD/month"
            echo "   Overage: \$$(echo "$TOTAL_COST - $THRESHOLD" | bc -l)/month"
            exit 1
          fi
          
          echo "‚úÖ Gate 3 (Cost Estimation) PASSED - Under threshold"

  terraform-apply:
    name: Apply Terraform Changes
    runs-on: ubuntu-latest
    needs: validate
    environment:
      name: production
      url: https://api.proteinclassifier.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/github-actions-terraform
          aws-region: ${{ vars.TF_STATE_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Init
        env:
          TF_STATE_BUCKET: ${{ vars.TF_STATE_BUCKET }}
          TF_STATE_KEY: ${{ vars.TF_STATE_KEY }}
          TF_STATE_REGION: ${{ vars.TF_STATE_REGION }}
          TF_STATE_DYNAMODB_TABLE: ${{ vars.TF_STATE_DYNAMODB_TABLE }}
        run: |
          terraform -chdir=terraform init \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="region=${TF_STATE_REGION}" \
            -backend-config="dynamodb_table=${TF_STATE_DYNAMODB_TABLE}"

      - name: Terraform Validate
        run: terraform -chdir=terraform validate

      - name: Download Cached Terraform Plan
        if: inputs.plan_run_id != ''
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          run-id: ${{ inputs.plan_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: terraform

      - name: Terraform Plan
        if: inputs.plan_run_id == ''
        id: plan
        run: |
          cd terraform
          terraform plan \
            -var="aws_account_id=${{ vars.AWS_ACCOUNT_ID || '000000000000' }}" \
            -out=tfplan.out \
            -no-color
          
          # Show the plan
          terraform show -no-color tfplan.out

      - name: Upload Terraform Plan Artifact
        if: inputs.plan_run_id == ''
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/tfplan.out
          retention-days: 7

      - name: Import Existing Resources (if any)
        if: false  # TODO: Fix hanging import step
        run: |
          cd terraform
          echo "üîÑ Attempting to import any existing resources..."
          # Helper function to sanitize sensitive information from error output
          sanitize_output() {
            local output="$1"
            # Redact AWS account IDs (12-digit numbers)
            output=$(echo "$output" | sed -E 's/[0-9]{12}/************/g')
            # Redact ARNs
            output=$(echo "$output" | sed -E 's/arn:aws:[a-z0-9-]+:[a-z0-9-]*:[0-9]{12}:[^ ]*/arn:aws:***:***:************:***/g')
            # Redact resource IDs that look like AWS IDs (e.g., i-xxxxx, vpc-xxxxx)
            output=$(echo "$output" | sed -E 's/(i|vpc|subnet|sg|igw|rtb|nat|eni|vol|snap|ami)-[a-z0-9]+/\1-***/g')
            echo "$output"
          }
          
          # Helper function to check if error output contains critical errors
          # Returns 0 if critical error found, 1 otherwise
          check_critical_error() {
            local output="$1"
            if echo "$output" | grep -qiE "(authentication|unauthorized|forbidden|access denied|invalid credentials|expiredtoken|invalidclienttokenid|connection|network|timeout|state lock|lockinfo)"; then
              return 0
            fi
            return 1
          }
          
          # Helper function to safely import resources
          # Allows benign "resource already exists" or "resource not found" import errors, but fails on auth/network/locking errors
          safe_import() {
            local resource_address="$1"
            local resource_id="$2"
            local description="$3"
            
            local output
            local exit_code
            
            # Temporarily disable 'set -e' to capture the import exit code without aborting the step
            set +e
            output=$(timeout 300 terraform import "$resource_address" "$resource_id" 2>&1)
            exit_code=$?
            set -e
            
            # If import succeeded, we're done
            if [ "$exit_code" -eq 0 ]; then
              echo "‚úÖ $description: imported successfully"
              return 0
            fi
            
            # Check if the operation timed out (timeout command returns 124)
            if [ "$exit_code" -eq 124 ]; then
              echo "‚ùå TIMEOUT importing $description:"
              echo "The terraform import operation exceeded the 300 second timeout"
              echo "::error::Import operation timed out after 300 seconds"
              return 1
            fi
            
            # Check for benign errors (already in state or doesn't exist)
            if echo "$output" | grep -qE "(already exists|already imported|already manages|already|Cannot import non-existent|does not exist|Resource not found)"; then
              echo "‚ÑπÔ∏è  $description: already in state or doesn't exist"
              return 0
            fi
            
            # Check for critical errors that should fail the workflow
            if check_critical_error "$output"; then
              echo "‚ùå CRITICAL ERROR importing $description:"
              echo "$(sanitize_output "$output")"
              echo "::error::Import failed with critical error - check AWS credentials, network, state locking, or Terraform state access"
              return 1
            fi
            
            # Unknown error - fail to be safe
            echo "‚ö†Ô∏è  Unknown error importing $description:"
            echo "$(sanitize_output "$output")"
            echo "::error::Import failed with unexpected error"
            return 1
          }
          
          # Helper function to get AWS resource ARN with error checking
          get_aws_resource() {
            local description="$1"
            shift
            local aws_cmd=("$@")
            
            local output
            local exit_code
            
            # Temporarily disable 'set -e' to capture the AWS CLI exit code without aborting the step
            set +e
            output=$("${aws_cmd[@]}" 2>&1)
            exit_code=$?
            set -e
            
            if [ "$exit_code" -eq 0 ]; then
              echo "$output"
              return 0
            fi
            
            # Check for critical AWS errors
            if check_critical_error "$output"; then
              echo "‚ùå CRITICAL ERROR querying AWS for $description:"
              echo "$(sanitize_output "$output")"
              echo "::error::AWS query failed with critical error - check credentials and network"
              return 1
            fi
            
            # Resource not found is acceptable
            echo "none"
            return 0
          }
          
          # Import resources with proper error handling
          safe_import "aws_s3_bucket.alb_logs" "protein-classifier-alb-logs-${{ vars.AWS_ACCOUNT_ID }}" "S3 bucket" || exit 1
          
          TG_ARN=$(get_aws_resource "target group" aws elbv2 describe-target-groups --names protein-classifier-ecs-tg --query 'TargetGroups[0].TargetGroupArn' --output text) || exit 1
          if [ "$TG_ARN" != "none" ] && [ "$TG_ARN" != "" ]; then
            safe_import "aws_lb_target_group.ecs" "$TG_ARN" "Target group" || exit 1
          fi
          
          safe_import "aws_dynamodb_table.terraform_locks" "protein-classifier-terraform-locks" "DynamoDB table" || exit 1
          safe_import "aws_ecr_repository.api" "protein-classifier-api" "ECR repository" || exit 1
          safe_import "aws_cloudwatch_log_group.ecs_logs" "/ecs/protein-classifier-api" "CloudWatch logs (ECS)" || exit 1
          safe_import "aws_cloudwatch_log_group.vpc_flow_logs" "/aws/vpc/protein-classifier-flow-logs" "CloudWatch logs (VPC)" || exit 1
          safe_import "aws_iam_role.github_actions" "protein-classifier-github-actions-role" "IAM role (GitHub Actions)" || exit 1
          safe_import "aws_iam_role.ecs_task_execution_role" "protein-classifier-ecs-task-execution-role" "IAM role (ECS execution)" || exit 1
          safe_import "aws_iam_role.ecs_task_role" "protein-classifier-ecs-task-role" "IAM role (ECS task)" || exit 1
          safe_import "aws_iam_role.vpc_flow_logs" "protein-classifier-vpc-flow-logs-role" "IAM role (VPC flow logs)" || exit 1
          
          echo "‚úÖ Import step complete"

      # Backup current state before applying changes
      # This enables rollback to previous stable state if apply fails
      - name: Backup Current State
        id: backup
        run: |
          cd terraform
          echo "üíæ Backing up current Terraform state..."
          
          # Pull latest state from remote backend
          terraform state pull > /tmp/terraform-state-backup.json
          
          # Get list of current resources for comparison
          terraform state list > /tmp/terraform-resources-before.txt
          
          echo "‚úÖ State backup completed"
          echo "üìã Current resources:"
          cat /tmp/terraform-resources-before.txt
          echo ""
          echo "Backup saved to /tmp/terraform-state-backup.json"

      - name: Terraform Apply
        id: apply
        run: |
          cd terraform
          echo "üöÄ Applying Terraform changes..."
          terraform apply -auto-approve -no-color tfplan.out
          echo "‚úÖ Terraform apply completed successfully!"

      # Automatic rollback mechanism - only triggers on apply failure
      # Identifies and destroys only resources created in the failed apply
      # Restores infrastructure to previous stable state
      - name: Rollback on Failure
        if: failure() && steps.apply.outcome == 'failure'
        run: |
          cd terraform
          echo "## üîÑ Automatic Rollback Triggered" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ö†Ô∏è  Terraform apply failed. Initiating automatic rollback..." | tee -a $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Get list of resources after failed apply
          echo "üìã Identifying resources created in failed apply..."
          if terraform state list > /tmp/terraform-resources-after.txt 2>&1; then
            echo "‚úÖ Successfully retrieved post-apply state"
          else
            echo "‚ö†Ô∏è  Warning: Could not retrieve post-apply state"
            echo "This may indicate state corruption or early apply failure"
            # Create empty file to allow comparison to proceed
            touch /tmp/terraform-resources-after.txt
          fi
          
          # Compare states to find newly created resources
          # These are resources that exist in 'after' but not in 'before'
          echo "üîç Comparing states to identify new resources..."
          
          # Ensure both files exist before comparison
          if [ ! -f /tmp/terraform-resources-before.txt ]; then
            echo "‚ùå Error: Pre-apply state backup not found"
            exit 1
          fi
          
          # Use safer comparison with explicit file checks
          NEW_RESOURCES=""
          if [ -f /tmp/terraform-resources-after.txt ]; then
            NEW_RESOURCES=$(comm -13 \
              <(sort /tmp/terraform-resources-before.txt 2>/dev/null || echo "") \
              <(sort /tmp/terraform-resources-after.txt 2>/dev/null || echo "") || echo "")
          fi
          
          if [ -z "$NEW_RESOURCES" ]; then
            echo "‚ÑπÔ∏è  No new resources found to rollback" | tee -a $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The apply failed before creating any resources." | tee -a $GITHUB_STEP_SUMMARY
            echo "Previous infrastructure state remains intact." | tee -a $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          echo "### Resources to Rollback:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$NEW_RESOURCES" | tee -a $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Attempt to destroy newly created resources
          echo "üóëÔ∏è  Rolling back newly created resources..."
          ROLLBACK_FAILED=false
          
          while IFS= read -r resource; do
            if [ -n "$resource" ]; then
              echo "  Destroying: $resource"
              # Add timeout to prevent hanging on stuck resources (5 minutes per resource)
              if timeout 300 terraform destroy -auto-approve -target="$resource" -no-color; then
                echo "    ‚úÖ Successfully destroyed: $resource" | tee -a $GITHUB_STEP_SUMMARY
              else
                DESTROY_EXIT=$?
                if [ $DESTROY_EXIT -eq 124 ]; then
                  echo "    ‚è±Ô∏è  Timeout destroying: $resource (exceeded 5 minutes)" | tee -a $GITHUB_STEP_SUMMARY
                else
                  echo "    ‚ùå Failed to destroy: $resource (exit code: $DESTROY_EXIT)" | tee -a $GITHUB_STEP_SUMMARY
                fi
                ROLLBACK_FAILED=true
              fi
            fi
          done <<< "$NEW_RESOURCES"
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check if rollback was successful
          if [ "$ROLLBACK_FAILED" = true ]; then
            echo "### ‚ö†Ô∏è  Rollback Partially Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Some resources could not be automatically destroyed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "#### Manual Recovery Required:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "1. Review the AWS Console to identify orphaned resources" >> $GITHUB_STEP_SUMMARY
            echo "2. Manually destroy failed resources using:" >> $GITHUB_STEP_SUMMARY
            echo '   ```bash' >> $GITHUB_STEP_SUMMARY
            echo "   terraform destroy -target=<resource_address>" >> $GITHUB_STEP_SUMMARY
            echo '   ```' >> $GITHUB_STEP_SUMMARY
            echo "3. Verify state consistency with:" >> $GITHUB_STEP_SUMMARY
            echo '   ```bash' >> $GITHUB_STEP_SUMMARY
            echo "   terraform state list" >> $GITHUB_STEP_SUMMARY
            echo "   terraform plan" >> $GITHUB_STEP_SUMMARY
            echo '   ```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ùå Rollback completed with errors. Manual intervention required." | tee -a $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "### ‚úÖ Rollback Successful" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All newly created resources have been destroyed." >> $GITHUB_STEP_SUMMARY
            echo "Infrastructure has been restored to previous stable state." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Verify final state
            echo "### Final State Verification:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            terraform state list | tee -a $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "‚úÖ Rollback completed successfully" | tee -a $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è  Note: The original apply failure still needs to be investigated and resolved." | tee -a $GITHUB_STEP_SUMMARY
            exit 0
          fi

      - name: Output Infrastructure Details
        if: success()
        run: |
          cd terraform
          echo "## üéâ Infrastructure Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
