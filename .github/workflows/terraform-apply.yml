name: Terraform Apply

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "apply" to confirm infrastructure changes'
        required: true
        type: string
      plan_run_id:
        description: 'Optional: Workflow run ID containing cached Terraform plan'
        required: false
        type: string
        default: ''

# Prevent concurrent Terraform runs to avoid state lock conflicts
concurrency:
  group: terraform-apply
  cancel-in-progress: false

permissions:
  contents: read
  id-token: write
  pull-requests: write

env:
  COST_THRESHOLD: 125  # Monthly cost threshold in USD

jobs:
  validate:
    name: Pre-Apply Validation (Triple-Gated)
    runs-on: ubuntu-latest

    steps:
      - name: Verify Confirmation
        run: |
          if [ "${{ inputs.confirm }}" != "apply" ]; then
            echo "‚ùå Confirmation failed. You must type 'apply' to proceed."
            exit 1
          fi
          echo "‚úÖ Confirmation received. Proceeding with validation..."

      - name: Checkout code
        uses: actions/checkout@v6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/github-actions-terraform
          aws-region: ${{ vars.TF_STATE_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: latest

      - name: Terraform Init
        env:
          TF_STATE_BUCKET: ${{ vars.TF_STATE_BUCKET }}
          TF_STATE_KEY: ${{ vars.TF_STATE_KEY }}
          TF_STATE_REGION: ${{ vars.TF_STATE_REGION }}
          TF_STATE_DYNAMODB_TABLE: ${{ vars.TF_STATE_DYNAMODB_TABLE }}
        run: |
          terraform -chdir=terraform init \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="region=${TF_STATE_REGION}" \
            -backend-config="dynamodb_table=${TF_STATE_DYNAMODB_TABLE}"

      # Gate 1: TFLint
      - name: Gate 1 - TFLint Validation
        run: |
          cd terraform
          tflint --init
          echo "üîç Running TFLint validation..."
          tflint --format compact --minimum-failure-severity=error
          echo "‚úÖ Gate 1 (TFLint) PASSED"

      # Gate 2: Trivy Terraform Security Scan
      - name: Gate 2 - Trivy Terraform Scan
        id: trivy
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: 'config'
          scan-ref: 'terraform'
          format: 'json'
          output: 'trivy-terraform.json'
          exit-code: '0'  # Don't fail the action itself, we'll parse results

      - name: Gate 2 Status
        if: always()
        run: |
          echo "### üîí Gate 2: Trivy Terraform Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          REPORT=trivy-terraform.json
          if [ -f "$REPORT" ]; then
            TOTAL=$(jq -r '(.Results // []) | map(.Misconfigurations // []) | flatten | length' "$REPORT")
            # Count findings by severity level
            CRITICAL=$(jq -r '(.Results // []) | map(.Misconfigurations // []) | flatten | map(select(.Severity=="CRITICAL")) | length' "$REPORT")
            HIGH=$(jq -r '(.Results // []) | map(.Misconfigurations // []) | flatten | map(select(.Severity=="HIGH")) | length' "$REPORT")
            MEDIUM=$(jq -r '(.Results // []) | map(.Misconfigurations // []) | flatten | map(select(.Severity=="MEDIUM")) | length' "$REPORT")
            LOW=$(jq -r '(.Results // []) | map(.Misconfigurations // []) | flatten | map(select(.Severity=="LOW")) | length' "$REPORT")

            echo "- Findings: $TOTAL" >> $GITHUB_STEP_SUMMARY
            echo "  - CRITICAL: $CRITICAL" >> $GITHUB_STEP_SUMMARY
            echo "  - HIGH:     $HIGH" >> $GITHUB_STEP_SUMMARY
            echo "  - MEDIUM:   $MEDIUM" >> $GITHUB_STEP_SUMMARY
            echo "  - LOW:      $LOW" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Validate TOTAL is a number before comparison
            if [[ "$TOTAL" =~ ^[0-9]+$ ]]; then
              if [ "$TOTAL" -gt 0 ]; then
                echo "‚ùå Security issues detected"
                echo "**Security findings must be addressed before applying infrastructure changes.**"
                echo ""
                echo "Security findings breakdown:"
                echo "  - CRITICAL: $CRITICAL"
                echo "  - HIGH: $HIGH"
                echo "  - MEDIUM: $MEDIUM"
                echo "  - LOW: $LOW"
                echo ""
                echo "Running Trivy with detailed output:"
                echo ""
                docker run --rm -v "${GITHUB_WORKSPACE:-$PWD}:/src" aquasec/trivy:latest config /src/terraform
                echo ""
                echo "‚ùå Gate 2 (Trivy) FAILED"
                echo "‚ùå Security issues detected" >> $GITHUB_STEP_SUMMARY
                echo "**Security findings must be addressed before applying infrastructure changes.**" >> $GITHUB_STEP_SUMMARY
                echo "‚ùå Gate 2 (Trivy) FAILED" >> $GITHUB_STEP_SUMMARY
                exit 1
              else
                echo "‚úÖ No security issues found"
                echo "‚úÖ Gate 2 (Trivy) PASSED"
                echo "‚úÖ No security issues found" >> $GITHUB_STEP_SUMMARY
                echo "‚úÖ Gate 2 (Trivy) PASSED" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "‚ö†Ô∏è Unable to parse Trivy findings count from report (TOTAL=\"$TOTAL\")."
              echo "‚ùå Gate 2 (Trivy) FAILED"
              echo "‚ö†Ô∏è Unable to parse Trivy findings count from report (TOTAL=\"$TOTAL\")." >> $GITHUB_STEP_SUMMARY
              echo "‚ùå Gate 2 (Trivy) FAILED" >> $GITHUB_STEP_SUMMARY
              exit 1
            fi
          else
            # Report file is missing - this is an error condition
            echo "‚ùå Trivy report file not found"
            echo "‚ùå Gate 2 (Trivy) FAILED"
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ùå Trivy report file not found - cannot verify security posture" >> $GITHUB_STEP_SUMMARY
            echo "‚ùå Gate 2 (Trivy) FAILED" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      # Gate 3: Cost Estimation
      - name: Setup Infracost
        uses: infracost/actions/setup@v3
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY }}

      - name: Gate 3 - Cost Estimation
        continue-on-error: true # Skip cost estimation gate for now
        run: |
          cd terraform
          echo "üí∞ Generating cost estimate..."
          infracost breakdown --path . \
            --terraform-var="aws_account_id=${{ vars.AWS_ACCOUNT_ID || '000000000000' }}" \
            --format json \
            --out-file /tmp/infracost.json
          
          # Extract total monthly cost
          TOTAL_COST=$(jq -r '.totalMonthlyCost' /tmp/infracost.json)
          THRESHOLD=${{ env.COST_THRESHOLD }}
          
          echo "üìä Total Monthly Cost: \$$TOTAL_COST"
          echo "üéØ Cost Threshold: \$$THRESHOLD"
          
          # Compare costs (using bc for decimal comparison)
          if [ $(echo "$TOTAL_COST > $THRESHOLD" | bc -l) -eq 1 ]; then
            echo "‚ùå COST THRESHOLD EXCEEDED!"
            echo "   Estimated: \$$TOTAL_COST/month"
            echo "   Threshold: \$$THRESHOLD/month"
            echo "   Overage: \$$(echo "$TOTAL_COST - $THRESHOLD" | bc -l)/month"
            exit 1
          fi
          
          echo "‚úÖ Gate 3 (Cost Estimation) PASSED - Under threshold"

  terraform-apply:
    name: Apply Terraform Changes
    runs-on: ubuntu-latest
    needs: validate
    environment:
      name: production
      url: https://api.proteinclassifier.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/github-actions-terraform
          aws-region: ${{ vars.TF_STATE_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Init
        env:
          TF_STATE_BUCKET: ${{ vars.TF_STATE_BUCKET }}
          TF_STATE_KEY: ${{ vars.TF_STATE_KEY }}
          TF_STATE_REGION: ${{ vars.TF_STATE_REGION }}
          TF_STATE_DYNAMODB_TABLE: ${{ vars.TF_STATE_DYNAMODB_TABLE }}
        run: |
          terraform -chdir=terraform init \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="region=${TF_STATE_REGION}" \
            -backend-config="dynamodb_table=${TF_STATE_DYNAMODB_TABLE}"

      - name: Terraform Validate
        run: terraform -chdir=terraform validate

      - name: Download Cached Terraform Plan
        if: inputs.plan_run_id != ''
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          run-id: ${{ inputs.plan_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: terraform

      - name: Terraform Plan
        if: inputs.plan_run_id == ''
        id: plan
        run: |
          cd terraform
          terraform plan \
            -var="aws_account_id=${{ vars.AWS_ACCOUNT_ID || '000000000000' }}" \
            -out=tfplan.out \
            -no-color
          
          # Show the plan
          terraform show -no-color tfplan.out

      - name: Upload Terraform Plan Artifact
        if: inputs.plan_run_id == ''
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/tfplan.out
          retention-days: 7

      - name: Import Existing Resources (if any)
        if: false  # TODO: Fix hanging import step
        run: |
          cd terraform
          echo "üîÑ Attempting to import any existing resources..."
          # Helper function to sanitize sensitive information from error output
          sanitize_output() {
            local output="$1"
            # Redact AWS account IDs (12-digit numbers)
            output=$(echo "$output" | sed -E 's/[0-9]{12}/************/g')
            # Redact ARNs
            output=$(echo "$output" | sed -E 's/arn:aws:[a-z0-9-]+:[a-z0-9-]*:[0-9]{12}:[^ ]*/arn:aws:***:***:************:***/g')
            # Redact resource IDs that look like AWS IDs (e.g., i-xxxxx, vpc-xxxxx)
            output=$(echo "$output" | sed -E 's/(i|vpc|subnet|sg|igw|rtb|nat|eni|vol|snap|ami)-[a-z0-9]+/\1-***/g')
            echo "$output"
          }
          
          # Helper function to check if error output contains critical errors
          # Returns 0 if critical error found, 1 otherwise
          check_critical_error() {
            local output="$1"
            if echo "$output" | grep -qiE "(authentication|unauthorized|forbidden|access denied|invalid credentials|expiredtoken|invalidclienttokenid|connection|network|timeout|state lock|lockinfo)"; then
              return 0
            fi
            return 1
          }
          
          # Helper function to safely import resources
          # Allows benign "resource already exists" or "resource not found" import errors, but fails on auth/network/locking errors
          safe_import() {
            local resource_address="$1"
            local resource_id="$2"
            local description="$3"
            
            local output
            local exit_code
            
            # Temporarily disable 'set -e' to capture the import exit code without aborting the step
            set +e
            output=$(timeout 300 terraform import "$resource_address" "$resource_id" 2>&1)
            exit_code=$?
            set -e
            
            # If import succeeded, we're done
            if [ "$exit_code" -eq 0 ]; then
              echo "‚úÖ $description: imported successfully"
              return 0
            fi
            
            # Check if the operation timed out (timeout command returns 124)
            if [ "$exit_code" -eq 124 ]; then
              echo "‚ùå TIMEOUT importing $description:"
              echo "The terraform import operation exceeded the 300 second timeout"
              echo "::error::Import operation timed out after 300 seconds"
              return 1
            fi
            
            # Check for benign errors (already in state or doesn't exist)
            if echo "$output" | grep -qE "(already exists|already imported|already manages|already|Cannot import non-existent|does not exist|Resource not found)"; then
              echo "‚ÑπÔ∏è  $description: already in state or doesn't exist"
              return 0
            fi
            
            # Check for critical errors that should fail the workflow
            if check_critical_error "$output"; then
              echo "‚ùå CRITICAL ERROR importing $description:"
              echo "$(sanitize_output "$output")"
              echo "::error::Import failed with critical error - check AWS credentials, network, state locking, or Terraform state access"
              return 1
            fi
            
            # Unknown error - fail to be safe
            echo "‚ö†Ô∏è  Unknown error importing $description:"
            echo "$(sanitize_output "$output")"
            echo "::error::Import failed with unexpected error"
            return 1
          }
          
          # Helper function to get AWS resource ARN with error checking
          get_aws_resource() {
            local description="$1"
            shift
            local aws_cmd=("$@")
            
            local output
            local exit_code
            
            # Temporarily disable 'set -e' to capture the AWS CLI exit code without aborting the step
            set +e
            output=$("${aws_cmd[@]}" 2>&1)
            exit_code=$?
            set -e
            
            if [ "$exit_code" -eq 0 ]; then
              echo "$output"
              return 0
            fi
            
            # Check for critical AWS errors
            if check_critical_error "$output"; then
              echo "‚ùå CRITICAL ERROR querying AWS for $description:"
              echo "$(sanitize_output "$output")"
              echo "::error::AWS query failed with critical error - check credentials and network"
              return 1
            fi
            
            # Resource not found is acceptable
            echo "none"
            return 0
          }
          
          # Import resources with proper error handling
          safe_import "aws_s3_bucket.alb_logs" "protein-classifier-alb-logs-${{ vars.AWS_ACCOUNT_ID }}" "S3 bucket" || exit 1
          
          TG_ARN=$(get_aws_resource "target group" aws elbv2 describe-target-groups --names protein-classifier-ecs-tg --query 'TargetGroups[0].TargetGroupArn' --output text) || exit 1
          if [ "$TG_ARN" != "none" ] && [ "$TG_ARN" != "" ]; then
            safe_import "aws_lb_target_group.ecs" "$TG_ARN" "Target group" || exit 1
          fi
          
          safe_import "aws_dynamodb_table.terraform_locks" "protein-classifier-terraform-locks" "DynamoDB table" || exit 1
          safe_import "aws_ecr_repository.api" "protein-classifier-api" "ECR repository" || exit 1
          safe_import "aws_cloudwatch_log_group.ecs_logs" "/ecs/protein-classifier-api" "CloudWatch logs (ECS)" || exit 1
          safe_import "aws_cloudwatch_log_group.vpc_flow_logs" "/aws/vpc/protein-classifier-flow-logs" "CloudWatch logs (VPC)" || exit 1
          safe_import "aws_iam_role.github_actions" "protein-classifier-github-actions-role" "IAM role (GitHub Actions)" || exit 1
          safe_import "aws_iam_role.ecs_task_execution_role" "protein-classifier-ecs-task-execution-role" "IAM role (ECS execution)" || exit 1
          safe_import "aws_iam_role.ecs_task_role" "protein-classifier-ecs-task-role" "IAM role (ECS task)" || exit 1
          safe_import "aws_iam_role.vpc_flow_logs" "protein-classifier-vpc-flow-logs-role" "IAM role (VPC flow logs)" || exit 1
          
          echo "‚úÖ Import step complete"

      - name: Terraform Apply
        id: apply
        run: |
          cd terraform
          echo "üöÄ Applying Terraform changes..."
          terraform apply -auto-approve -no-color tfplan.out
          echo "‚úÖ Terraform apply completed successfully!"

      - name: Trigger Docker Build if Image Missing
        id: trigger-docker-build
        run: |
          echo "üîç Checking if Docker image exists in ECR..."
          
          # Check if ECR repository exists
          if ! aws ecr describe-repositories --repository-names protein-classifier-api --region us-west-2 >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  ECR repository was just created by Terraform"
            echo "Triggering Docker build workflow to create initial image..."
            echo "TRIGGER_BUILD=true" >> $GITHUB_OUTPUT
          else
            # Check if :latest image exists
            if aws ecr describe-images \
              --repository-name protein-classifier-api \
              --image-ids imageTag=latest \
              --region us-west-2 >/dev/null 2>&1; then
              echo "‚úÖ Docker image with :latest tag already exists"
              echo "TRIGGER_BUILD=false" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è  No :latest image found in ECR"
              echo "Triggering Docker build workflow..."
              echo "TRIGGER_BUILD=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Trigger Build and Push Docker Image Workflow
        if: steps.trigger-docker-build.outputs.TRIGGER_BUILD == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('üöÄ Triggering Build and Push Docker Image workflow...');
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'docker-build.yml',
              ref: 'main'
            });
            console.log('‚úÖ Docker build workflow triggered successfully');
            console.log('üïê Waiting 30 seconds for workflow to start...');
            await new Promise(resolve => setTimeout(resolve, 30000));

      - name: Wait for Docker Build Completion
        if: steps.trigger-docker-build.outputs.TRIGGER_BUILD == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('‚è≥ Waiting for Docker build workflow to complete...');
            const maxWaitMinutes = 10;
            const pollIntervalSeconds = 30;
            const maxAttempts = (maxWaitMinutes * 60) / pollIntervalSeconds;
            
            let attempts = 0;
            while (attempts < maxAttempts) {
              attempts++;
              
              // Get recent workflow runs for docker-build.yml
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'docker-build.yml',
                per_page: 5
              });
              
              // Find the most recent run
              const latestRun = runs.data.workflow_runs[0];
              
              if (latestRun) {
                console.log(`Status: ${latestRun.status}, Conclusion: ${latestRun.conclusion}`);
                
                if (latestRun.status === 'completed') {
                  if (latestRun.conclusion === 'success') {
                    console.log('‚úÖ Docker build completed successfully!');
                    return;
                  } else {
                    throw new Error(`‚ùå Docker build failed with conclusion: ${latestRun.conclusion}`);
                  }
                }
              }
              
              console.log(`Attempt ${attempts}/${maxAttempts} - waiting ${pollIntervalSeconds}s...`);
              await new Promise(resolve => setTimeout(resolve, pollIntervalSeconds * 1000));
            }
            
            throw new Error(`‚ùå Docker build did not complete within ${maxWaitMinutes} minutes`);

      - name: Force ECS Service Update
        if: steps.trigger-docker-build.outputs.TRIGGER_BUILD == 'true'
        run: |
          echo "üîÑ Forcing ECS service update to pull the newly built image..."
          aws ecs update-service \
            --cluster protein-classifier-api-1-0-0-prod-cluster \
            --service protein-classifier-api-service \
            --force-new-deployment \
            --region us-west-2
          
          echo "‚úÖ ECS service deployment triggered"

      - name: Output Infrastructure Details
        if: success()
        run: |
          cd terraform
          echo "## üéâ Infrastructure Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
